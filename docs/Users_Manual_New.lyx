#LyX 1.4.3 created this file. For more info see http://www.lyx.org/
\lyxformat 245
\begin_document
\begin_header
\textclass article
\language english
\inputencoding auto
\fontscheme default
\graphics default
\paperfontsize default
\papersize default
\use_geometry false
\use_amsmath 1
\cite_engine basic
\use_bibtopic false
\paperorientation portrait
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\defskip medskip
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\end_header

\begin_body

\begin_layout Section
Introduction
\end_layout

\begin_layout Standard
The PyFITS module is a Python library providing access to FITS files.
 FITS (Flexible Image Transport System) is a portable file standard widely
 used in the astronomy community to store images and tables.
 
\end_layout

\begin_layout Subsection
Install PyFITS 
\end_layout

\begin_layout Standard
PyFITS requires Python version 2.3 or newer.
 PyFITS also requires the numarray module.
 Information about numarray can be found in:
\end_layout

\begin_layout Itemize
http://www.stsci.edu/resources/software_hardware/numarray
\end_layout

\begin_layout Standard
To download numarray, go to:
\end_layout

\begin_layout Itemize
http://sourceforge.net/project/numpy
\end_layout

\begin_layout Standard
PyFITS's source code is pure Python.
 It can be downloaded from:
\end_layout

\begin_layout Itemize
http://www.stsci.edu/resources/software_hardware/pyfits/Download
\end_layout

\begin_layout Standard
PyFITS uses python's distutils for its installation.
 To install it, unpack the tar file and type:
\end_layout

\begin_layout Quotation
\begin_inset Box Shadowbox
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Standard

\emph on
python setup.py install
\end_layout

\end_inset


\end_layout

\begin_layout Standard
This will install pyfits, readgeis and fitsdiff in python's site-packages
 directory.
 If permissions do not allow this kind of installation PyFITS can be installed
 in a personal directory using one of the commands below.
 Note, that PYTHONPATH has to be set or modified accordingly.
 The three examples below show how to install PyFITS in an arbitrary directory
 <install-dir> and how to modify PYTHONPATH.
\newline

\end_layout

\begin_layout Standard

\emph on
python setup.py install --local=<install-dir> 
\end_layout

\begin_layout Standard

\emph on
setenv PYTHONPATH <install-dir>
\emph default

\newline

\end_layout

\begin_layout Standard

\emph on
python setup.py install --home=<install-dir> 
\end_layout

\begin_layout Standard

\emph on
setenv PYTHONPATH <install-dir>/lib/python
\emph default

\newline

\end_layout

\begin_layout Standard

\emph on
python setup.py install --prefix=<install-lib>
\end_layout

\begin_layout Standard

\emph on
setenv PYTHONPATH <install-dir>lib/python2.3/site-packages
\emph default

\newline

\end_layout

\begin_layout Standard
In this Guide, we'll assume that the reader has basic familiarity with Python.
 Familiarity with numarray is not required, but it will help to understand
 the data structures in PyFITS.
 
\end_layout

\begin_layout Subsection
User Support for PyFITS 
\end_layout

\begin_layout Standard
The official PyFITS web page is: 
\end_layout

\begin_layout Itemize
http://www.stsci.edu/resources/software_hardware/pyfits
\end_layout

\begin_layout Standard
If you have any question or comment regarding PyFITS, user support is available
 through the STScI Help Desk: 
\end_layout

\begin_layout Itemize
E-mail: help@stsci.edu 
\end_layout

\begin_layout Itemize
Phone: (410) 338-1082 
\end_layout

\begin_layout Section
A Quick Tutorial
\end_layout

\begin_layout Standard
This chapter provides a quick introduction of using PyFITS.
 The goal is to demonstrate PyFITS s basic features without getting into
 too much detail.
 If you are a first time user or an occasional PyFITS user, using only the
 most basic functionality, this is where you should start.
 Otherwise, it is safe to skip this chapter.
 
\end_layout

\begin_layout Standard
After installing numarray and PyFITS, start Python and load the PyFITS library.
 Note that the module name is all lower case.
\end_layout

\begin_layout Standard
\begin_inset Box Shadowbox
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Standard
>>> import pyfits
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Read and Update Existing FITS Files
\end_layout

\begin_layout Subsubsection
Open a FITS file
\end_layout

\begin_layout Standard
Once the PyFITS module is loaded, we can open an existing FITS file:
\end_layout

\begin_layout Standard
\begin_inset Box Shadowbox
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Standard
>>> hdulist = pyfits.open('input.fits')
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The 
\emph on
open()
\emph default
 function has several optional arguments which will be discussed in a later
 chapter.
 The default mode, as in the above example, is "readonly".
 The open method returns a PyFITS object called an HDUList which is a Python-lik
e list, consisting of HDU objects.
 An HDU (Header Data Unit) is the highest level component of the FITS file
 structure.
 So, after the above open call, hdulist[0] is the primary HDU, hdulist[1],
 if any, is the first extension HDU, etc.
 The HDUList has a useful method 
\emph on
info()
\emph default
, which summarizes the content of the opened FITS file:
\end_layout

\begin_layout Standard
\begin_inset Box Shadowbox
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Standard
>>> hdulist.info() 
\end_layout

\begin_layout Standard
Filename: test1.fits 
\end_layout

\begin_layout Standard
No.
 Name Type Cards Dimensions Format 
\end_layout

\begin_layout Standard
0 PRIMARY PrimaryHDU 220 () Int16 
\end_layout

\begin_layout Standard
1 SCI ImageHDU 61 (800, 800) Float32 
\end_layout

\begin_layout Standard
2 SCI ImageHDU 61 (800, 800) Float32 
\end_layout

\begin_layout Standard
3 SCI ImageHDU 61 (800, 800) Float32 
\end_layout

\begin_layout Standard
4 SCI ImageHDU 61 (800, 800) Float32
\end_layout

\end_inset


\end_layout

\begin_layout Standard
After you are done with the opened file, close it with the 
\emph on
close()
\emph default
 method:
\end_layout

\begin_layout Standard
\begin_inset Box Shadowbox
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Standard
>>> hdulist.close()
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The headers will still be accessable after the HDUlist is closed.
 The data may or may not be accessable depending on whether the data are
 touched and if they are memory-mapped, see later chapters for detail.
\end_layout

\begin_layout Subsubsection
Working with the Header
\end_layout

\begin_layout Standard
As mentioned earlier, each element of an HDUList is an HDU object with attribute
s of header and data, which can be used to access the header keywords and
 the data.
 The header attribute is a Header instance, another PyFITS object.
 To get the value of a header keyword, simply do (a la Python dictionaries):
\end_layout

\begin_layout Standard
\begin_inset Box Shadowbox
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Standard
>>> hdulist[0].header['targname'] 
\end_layout

\begin_layout Standard
'NGC121' 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
to get the value of the keyword targname, which is a string 'NGC121'.
 
\end_layout

\begin_layout Standard
Although keyword names are always in upper case inside the FITS file, specifying
 a keyword name with PyFITS is case-insensitive, for user s convenience.
 If the specified keyword name does not exist, it will raise a 
\emph on
KeyError
\emph default
 exception.
 We can also get the keyword value by indexing (a la Python lists):
\end_layout

\begin_layout Standard
\begin_inset Box Shadowbox
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Standard
>>> hdulist[0].header[27]
\end_layout

\begin_layout Standard
96
\end_layout

\end_inset


\end_layout

\begin_layout Standard
This example returns the 28th (like Python lists, it is 0-indexed) keyword's
 value, an integer, 96.
 
\end_layout

\begin_layout Standard
Similarly, it is easy to update a keyword s value in PyFITS, either through
 keyword name or index:
\end_layout

\begin_layout Standard
\begin_inset Box Shadowbox
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Standard
>>> prihdr = hdulist[0].header 
\end_layout

\begin_layout Standard
>>> hdr[ targname ] = 'NGC121-a' 
\end_layout

\begin_layout Standard
>>> hdr[27] = 99
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Use the above syntax if the keyword is already present in the header.
 If the keyword might not exist and you want to add it if it doesn t, use
 the 
\emph on
update()
\emph default
 method:
\end_layout

\begin_layout Standard
\begin_inset Box Shadowbox
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Standard
>>> prihdr.update('observer','Edwin Hubble')
\end_layout

\end_inset


\end_layout

\begin_layout Standard
A header consists of 
\emph on
Card
\emph default
 objects (i.e.
 the 80-column card-images specified in the FITS standard).
 Each Card normally has up to three parts: key, value, and comment.
 To see the entire list of cardimages of an HDU, use the 
\emph on
ascardlist()
\emph default
 method :
\end_layout

\begin_layout Standard
\begin_inset Box Shadowbox
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Standard
>>> print prihdr.ascardlist()[:3] 
\end_layout

\begin_layout Standard
SIMPLE = T / file does conform to FITS standard 
\end_layout

\begin_layout Standard
BITPIX = 16 / number of bits per data pixel 
\end_layout

\begin_layout Standard
NAXIS = 0 / number of data axes
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Only the first three cards are shown above.
 To get a list of all keywords, use the keys() method of the card list:
\end_layout

\begin_layout Standard
\begin_inset Box Shadowbox
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Standard
>>> prihdr.ascardlist().keys() 
\end_layout

\begin_layout Standard
['SIMPLE','BITPIX','NAXIS', ...]
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Working with Image Data
\end_layout

\begin_layout Standard
If an HDU's data is an image, the 
\emph on
data
\emph default
 attribute of the HDU object will return a numarray object.
 Refer to the numarray Manual for details of manipulating these numerical
 arrays.
\end_layout

\begin_layout Standard
\begin_inset Box Shadowbox
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Standard
>>> scidata = hdulist[1].data
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Here, scidata points to the data object in the second HDU (the first HDU,
 
\emph on
hdulist[0]
\emph default
, being the primary HDU) in 
\emph on
hdulist
\emph default
, which corresponds to the 
\emph on
'SCI'
\emph default
 extension.
 Alternatively, you can access the extension by its extension name (specified
 in the 
\emph on
EXTNAME
\emph default
 keyword):
\end_layout

\begin_layout Standard
\begin_inset Box Shadowbox
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Standard
>>> scidata = hdulist['SCI'].data
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\lyxline

\end_layout

\begin_layout Standard
If there is more than one extension with the same 
\emph on
EXTNAME, EXTVER's
\emph default
 value needs to be specified as the second argument, e.g.: 
\emph on
hdulist['sci',2]
\emph default
.
\end_layout

\begin_layout Standard

\lyxline

\end_layout

\begin_layout Standard
The returned numarray object has many attributes and methods for a user
 to get information about the array, e.
 g.:
\end_layout

\begin_layout Standard
\begin_inset Box Shadowbox
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Standard
>>> scidata.shape
\end_layout

\begin_layout Standard
(800, 800) 
\end_layout

\begin_layout Standard
>>> scidata.type() 
\end_layout

\begin_layout Standard
Float32
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Since image data is a numarray object, we can slice it, view it, and perform
 mathematical operations on it.
 To see the pixel value at x=5, y=2:
\end_layout

\begin_layout Standard
\begin_inset Box Shadowbox
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Standard
>>> print scidata[1,4]
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Note that, like C (and unlike FORTRAN), Python is 0-indexed and the indices
 have the slowest axis first and fast axis last, i.e.
 for a 2-D image, the fast axis (X-axis) which corresponds to the FITS NAXIS1
 keyword, is the second index.
 Similarly, the sub-section of x=11 to 20 (inclusive) and y=31 to 40 (inclusive)
 is:
\end_layout

\begin_layout Standard
\begin_inset Box Shadowbox
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Standard
>>> scidata[30:40, 10:20]
\end_layout

\end_inset


\end_layout

\begin_layout Standard
To update the value of a pixel or a sub-section:
\end_layout

\begin_layout Standard
\begin_inset Box Shadowbox
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Standard
>>> scidata[30:40,10:20] = scidata[1,4] = 999
\end_layout

\end_inset


\end_layout

\begin_layout Standard
This example changes the values of both the pixel [1,4] and the sub-section
 [30:40,10:20] to the new value of 999.
\end_layout

\begin_layout Standard
Next example of array arithmetics is to convert the image data from counts
 to flux:
\end_layout

\begin_layout Standard
\begin_inset Box Shadowbox
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Standard
>>> photflam = hdulist[1].header[ photflam ] 
\end_layout

\begin_layout Standard
>>> exptime = prihdr[ exptime ] 
\end_layout

\begin_layout Standard
>>> scidata *= photflam / exptime
\end_layout

\end_inset


\end_layout

\begin_layout Standard
This example performs the math on the array in-place, thereby keeping the
 memory usage to a minimum.
 (Note: before Python 2.2.3, the use of "*=" may cause an error, this is fixed
 in later Python versions.) 
\end_layout

\begin_layout Standard
If at this point you want to preserve all the changes you made and write
 it to a new file, you can use the 
\emph on
writeto()
\emph default
 method of HDUList (see below).
\end_layout

\begin_layout Subsubsection
Working with Table Data
\end_layout

\begin_layout Standard
If you are familiar with the record array in numarray, you will find the
 table data is basically a record array with some extra properties.
 But familiarity with record arrays is not a prerequisite for this Guide.
 
\end_layout

\begin_layout Standard
Like images, the data portion of a FITS table extension is in the 
\emph on
.data
\emph default
 attribute:
\end_layout

\begin_layout Standard
\begin_inset Box Shadowbox
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Standard
>>> hdulist = pyfits.open('table.fits') 
\end_layout

\begin_layout Standard
>>> tbdata = hdulist[1].data # assuming the first extension is a table
\end_layout

\end_inset


\end_layout

\begin_layout Standard
To see the first row of the table:
\end_layout

\begin_layout Standard
\begin_inset Box Shadowbox
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Standard
>>> print tbdata[0] 
\end_layout

\begin_layout Standard
(1, 'abc',3.7000002861022949,0)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Each 
\emph on
row
\emph default
 in the table is a Record object which looks like a (Python) tuple containing
 elements of heterogeneous data types.
 In this example: an integer, a string, a floating point number, and a Boolean
 value.
 So the table data are just an array of such Records.
 More commonly, a user is likely to access the data in a 
\emph on
column-wise
\emph default
 way.
 This is accomplished by using the 
\emph on
field()
\emph default
 method.
 To get the first 
\emph on
column
\emph default
 (or 
\emph on
field
\emph default
) of the table, use:
\end_layout

\begin_layout Standard
\begin_inset Box Shadowbox
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Standard
>>> tbdata.field(0)
\end_layout

\begin_layout Standard
array([1, 2])
\end_layout

\end_inset


\end_layout

\begin_layout Standard
A numarray object with the data type of the specified field is returned.
\end_layout

\begin_layout Standard
Like header keywords, a field can be referred either by index, as above,
 or by name:
\end_layout

\begin_layout Standard
\begin_inset Box Shadowbox
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Standard
>>> tbdata.field('id') 
\end_layout

\begin_layout Standard
array([1, 2])
\end_layout

\end_inset


\end_layout

\begin_layout Standard
But how do we know what field names we ve got? First, let's introduce another
 attribute of the table HDU: the 
\emph on
.columns
\emph default
 attribute:
\end_layout

\begin_layout Standard
\begin_inset Box Shadowbox
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Standard
>>> cols = hdulist[1].columns
\end_layout

\end_inset


\end_layout

\begin_layout Standard
This attribute is a 
\emph on
ColDefs
\emph default
 (column definitions) object.
 If we use its 
\emph on
info()
\emph default
 method:
\end_layout

\begin_layout Standard
\begin_inset Box Shadowbox
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Standard
>>> cols.info() 
\end_layout

\begin_layout Standard
name: 
\end_layout

\begin_layout Standard
['c1','c2','c3','c4'] 
\end_layout

\begin_layout Standard
format: 
\end_layout

\begin_layout Standard
['1J','3A','1E','1L'] 
\end_layout

\begin_layout Standard
unit: 
\end_layout

\begin_layout Standard
[ '', '', '', ''] 
\end_layout

\begin_layout Standard
null: 
\end_layout

\begin_layout Standard
[-2147483647, '', '', ''] 
\end_layout

\begin_layout Standard
bscale: 
\end_layout

\begin_layout Standard
[ '', '', 3, ''] 
\end_layout

\begin_layout Standard
bzero: 
\end_layout

\begin_layout Standard
[ '', '', 0.40000000000000002, ''] 
\end_layout

\begin_layout Standard
disp: 
\end_layout

\begin_layout Standard
[ 'I11' , 'A3' , 'G15.7' , 'L6' ] 
\end_layout

\begin_layout Standard
start: 
\end_layout

\begin_layout Standard
[ '', '', '', ''] 
\end_layout

\begin_layout Standard
dim: 
\end_layout

\begin_layout Standard
[ '', '', '', '']
\end_layout

\end_inset


\end_layout

\begin_layout Standard
it will show all its attributes, such as names, formats, bscales, bzeros,
 etc.
 We can also get these properties individually, e.g.:
\end_layout

\begin_layout Standard
\begin_inset Box Shadowbox
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Standard
>>> cols.names 
\end_layout

\begin_layout Standard
[ 'ID' , 'name' , 'mag' , 'flag' ]
\end_layout

\end_inset


\end_layout

\begin_layout Standard
returns a (Python) list of field names.
 
\end_layout

\begin_layout Standard
Since each field is a numarray object, we ll have the entire arsenal of
 numarray tools to use.
 We can reassign (update) the values:
\end_layout

\begin_layout Standard
\begin_inset Box Shadowbox
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Standard
>>> tbdata.field( 'flag' )[:] = 0
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The 
\emph on
info()
\emph default
 method of table data will show the attributes of the record array, many
 of them may seem esoteric to casual users:
\end_layout

\begin_layout Standard
\begin_inset Box Shadowbox
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Standard
>>> tbdata.info() 
\end_layout

\begin_layout Standard
class: <class pyfits.FITS_rec > 
\end_layout

\begin_layout Standard
shape: (2,) 
\end_layout

\begin_layout Standard
strides: (12,) 
\end_layout

\begin_layout Standard
byteoffset: 0 
\end_layout

\begin_layout Standard
bytestride: 12 
\end_layout

\begin_layout Standard
itemsize: 12 
\end_layout

\begin_layout Standard
aligned: 0 
\end_layout

\begin_layout Standard
contiguous: 1 
\end_layout

\begin_layout Standard
buffer: <memory at 0x092dc3d8 with size:0x00000018 held by 
\end_layout

\begin_layout Standard
object 0x4086eb20 aliasing object 0x00000000> 
\end_layout

\begin_layout Standard
data pointer: 0x092dc3d8 (DEBUG ONLY) 
\end_layout

\begin_layout Standard
field names: [ 'c1' , 'c2' , 'c3' , 'c4 '] 
\end_layout

\begin_layout Standard
field formats: [ '1Int32' , '1a3' , '1Float32' , '1Int8' ]
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Create New FITS Files
\end_layout

\begin_layout Subsubsection
Save Changes
\end_layout

\begin_layout Standard
As mentioned earlier, after a user opened a file, made a few changes to
 either header or data, the user can use the 
\emph on
writeto()
\emph default
 method in 
\emph on
HDUList
\emph default
 to save the changes.
 This takes the version of headers and data in memory and writes them to
 a new FITS file on disk.
 Subsequent operations can be performed to the data in memory and written
 out to yet another different file, all without recopying the original data
 to (more) memory.
\end_layout

\begin_layout Standard
\begin_inset Box Shadowbox
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Standard
>>> hdulist.writeto('newimage.fits')
\end_layout

\end_inset


\end_layout

\begin_layout Standard
will write the current content of 
\emph on
hdulist
\emph default
 to a new disk file 
\emph on
newfile.fits
\emph default
.
 If a file was opened with the 
\emph on
update
\emph default
 mode, the 
\emph on
flush()
\emph default
 method can also be used to write all the changes made since 
\emph on
open()
\emph default
, back to the original file.
 The 
\emph on
close()
\emph default
 method will do the same for a FITS file opened with 
\emph on
update
\emph default
 mode.
\end_layout

\begin_layout Standard
\begin_inset Box Shadowbox
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Standard
>>> f = pyfits.open('original.fits', mode='update') 
\end_layout

\begin_layout Standard
...
 # making changes in data and/or header 
\end_layout

\begin_layout Standard
>>> f.flush() # changes are written back to original.fits
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Create FITS Images from Scratch
\end_layout

\begin_layout Standard
So far we have demonstrated how to read and update an existing FITS file.
 But how about creating a new FITS file from scratch? Such task is very
 easy in PyFITS for an image HDU.
 We ll first demonstrate how to create a FITS file consisting only the primary
 HDU with image data.
 First, we create a numarray object for the data part:
\end_layout

\begin_layout Standard
\begin_inset Box Shadowbox
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Standard
>>> import numarray 
\end_layout

\begin_layout Standard
>>> n = numarray.arange(100) # a simple sequence from 0 to 99
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Next, we create a 
\emph on
PrimaryHDU
\emph default
 object to encapsulate the data:
\end_layout

\begin_layout Standard
\begin_inset Box Shadowbox
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Standard
>>> hdu = pyfits.PrimaryHDU(n)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
we then create a 
\emph on
HDUList
\emph default
 to contain the newly created primary HDU, and write to a new file:
\end_layout

\begin_layout Standard
\begin_inset Box Shadowbox
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Standard
>>> hdulist = pyfits.HDUList([hdu]) 
\end_layout

\begin_layout Standard
>>> hdulist.writeto('new.fits')
\end_layout

\end_inset


\end_layout

\begin_layout Standard
That's it! In fact, PyFITS even provides a short cut for the last two lines:
\end_layout

\begin_layout Standard
\begin_inset Box Shadowbox
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Standard
>>> hdu.writeto('new.fits')
\end_layout

\end_inset


\end_layout

\begin_layout Standard
accomplishes the same!
\end_layout

\begin_layout Subsubsection
Create FITS Tables from Scratch
\end_layout

\begin_layout Standard
To create a table HDU is a little more involved than image HDU, because
 table's structure needs more information.
 First of all, tables can only be an extension HDU, not a primary.
 There are two kinds of FITS table extensions: ASCII and binary.
 We'll use binary table examples here.
 
\end_layout

\begin_layout Standard
To create a table from scratch, we need to define columns first, by constructing
 the 
\emph on
Column
\emph default
 objects and their data.
 Say, we have two columns, the first contains strings, and the second contains
 floating point numbers
\end_layout

\begin_layout Standard
\begin_inset Box Shadowbox
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Standard
>>> a1=numarray.strings.array(['NGC1001','NGC1002','NGC1003']) 
\end_layout

\begin_layout Standard
>>> a2=numarray.array([11.1,12.3,15.2]) 
\end_layout

\begin_layout Standard
>>> col1=pyfits.Column(name='target', format='20A', array=a1) 
\end_layout

\begin_layout Standard
>>> col2=pyfits.Column(name='V_mag', format='E', array=a2)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Second, create a 
\emph on
ColDefs
\emph default
 (column-definitions) object for all columns:
\end_layout

\begin_layout Standard
\begin_inset Box Shadowbox
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Standard
>>> cols=pyfits.ColDefs([col1, col2])
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Now, create a new binary table HDU object by using the PyFITS function 
\emph on
new_table()
\emph default
:
\end_layout

\begin_layout Standard
\begin_inset Box Shadowbox
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Standard
>>> tbhdu=pyfits.new_table(cols)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
This function returns (in this case) a 
\emph on
BinTableHDU
\emph default
.
 Append it to the hdulist we already have:
\end_layout

\begin_layout Standard
\begin_inset Box Shadowbox
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Standard
>>> hdulist.append(tbhdu)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
or create a new 
\emph on
HDUList
\emph default
 and go through the same steps as you did for the 
\emph on
ImageHDU
\emph default
.
 If this will be the only extension of the new FITS file 
\emph on
and
\emph default
 you only have a minimal primary HDU with no data, PyFITS again provides
 a short cut:
\end_layout

\begin_layout Standard
\begin_inset Box Shadowbox
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Standard
tbhdu.writeto('table.fits')
\end_layout

\end_inset


\end_layout

\begin_layout Standard
So far, we have covered the most basic features of PyFITS.
 In the following chapters we ll show more advanced examples and explain
 options in each class and method.
\end_layout

\begin_layout Subsection
Use the Convenience Functions
\end_layout

\begin_layout Standard
PyFITS also provides several high level ("convenience") functions.
 Such a convenience function is a "canned" operation to achieve one simple
 task.
 By using these "convenience" functions, a user does not have to worry about
 opening or closing a file, all the housekeeping is done implicitly.
 
\end_layout

\begin_layout Standard
The first of these functions is 
\emph on
getheader()
\emph default
, to get the header of an HDU.
 Here are several examples of getting the header.
 Only the file name is required for this function.
 The rest of the arguments are optional and flexible to specifiy which HDU
 the user wants to get:
\end_layout

\begin_layout Standard
\begin_inset Box Shadowbox
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Standard
>>> getheader('in.fits') # get default HDU (=0), i.e.
 primary HDU's header 
\end_layout

\begin_layout Standard
>>> getheader('in.fits', 0) # get primary HDU's header 
\end_layout

\begin_layout Standard
>>> getheader('in.fits', 2) # the second extension
\newline

\end_layout

\begin_layout Standard
# the HDU with EXTNAME='sci' (if there is only 1) 
\end_layout

\begin_layout Standard
>>> getheader('in.fits','sci ')
\newline
 
\end_layout

\begin_layout Standard
# the HDU with EXTNAME='sci' and EXTVER=2 
\end_layout

\begin_layout Standard
>>> getheader('in.fits','sci', 2) 
\end_layout

\begin_layout Standard
>>> getheader('in.fits', ('sci', 2)) # use a tuple to do the same
\newline
 
\end_layout

\begin_layout Standard
>>> getheader('in.fits', ext=2) # the second extension
\newline
 
\end_layout

\begin_layout Standard
# the 'sci' extension, if there is only 1 
\end_layout

\begin_layout Standard
>>> getheader('in.fits', extname= 'sci' )
\newline

\end_layout

\begin_layout Standard
# the HDU with EXTNAME='sci' and EXTVER=2 
\end_layout

\begin_layout Standard
>>> getheader('in.fits', extname='sci' , extver=2)
\newline
 
\end_layout

\begin_layout Standard
# ambiguous specifications will raise an exception, DON"T DO IT!! 
\end_layout

\begin_layout Standard
>>> getheader('in.fits', ext=('sci',1), extname='err', extver=2)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
After you get the header, you can access the information in it, such as
 getting and modifying a keyword value:
\end_layout

\begin_layout Standard
\begin_inset Box Shadowbox
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Standard
>>> from pyfits import getheader 
\end_layout

\begin_layout Standard
>>> hdr = getheader('in.fits', 1) # get first extension's header 
\end_layout

\begin_layout Standard
>>> filter = hdr['filter'] # get the value of the keyword "filter
\begin_inset Quotes erd
\end_inset

 
\end_layout

\begin_layout Standard
>>> val = hdr[10] # get the 11th keyword's value 
\end_layout

\begin_layout Standard
>>> hdr['filter']= 'FW555' # change the keyword value
\end_layout

\end_inset


\end_layout

\begin_layout Standard
For the header keywords, the header is like a dictionary, as well as a list.
 The user can access the keywords either by name or by numerix index, as
 explained earlier in this chapter.
\end_layout

\begin_layout Standard
If a user only needs to 
\emph on
read
\emph default
 one keyword, the 
\emph on
getval()
\emph default
 function can further simplify to just one call, instead of two as shown
 in the above examples:
\end_layout

\begin_layout Standard
\begin_inset Box Shadowbox
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Standard
>>> from pyfits import getval 
\end_layout

\begin_layout Standard
# get 1st extension's keyword FILTER's value 
\end_layout

\begin_layout Standard
>>> flt = getval('in.fits','filter', 1) 
\end_layout

\begin_layout Standard
# get the 2nd sci extension's 11th keyword's value
\end_layout

\begin_layout Standard
>>> val = getval('in.fits', 10, 'sci', 2) 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The function 
\emph on
getdata()
\emph default
 gets the data of an HDU.
 Similar to 
\emph on
getheader()
\emph default
, it only requires the input FITS file name while the extension is specified
 through the optional arguments.
 It does have one extra optional arguemnt 
\emph on
header
\emph default
.
 If 
\emph on
header
\emph default
 is set to True, this function will return both data and header, otherwise
 only data is returned.
\end_layout

\begin_layout Standard
\begin_inset Box Shadowbox
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Standard
>>> from pyfits import getdata 
\end_layout

\begin_layout Standard
>>> dat = getdata('in.fits','sci', 3) # get 3rd sci extension's data
\newline
 
\end_layout

\begin_layout Standard
# get 1st extension's data and header 
\end_layout

\begin_layout Standard
>>> data, hdr = getdata('in.fits', 1, header=True)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The functions introduced above are for reading.
 The next few functions demonstrate convenience functions for writing:
\end_layout

\begin_layout Standard
\begin_inset Box Shadowbox
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Standard
>>> pyfits.writeto('out.fits', data, header)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The 
\emph on
writeto()
\emph default
 function uses the provided data and an optional header to write to an output
 FITS file.
\end_layout

\begin_layout Standard
\begin_inset Box Shadowbox
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Standard
>>> pyfits.append('out.fits', data, header)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The 
\emph on
append()
\emph default
 function will use the provided data and the optional header to append to
 an existing FITS file.
 If the specified output file does not exist, it will create one.
\end_layout

\begin_layout Standard
\begin_inset Box Shadowbox
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Standard
>>> from pyfits import update 
\end_layout

\begin_layout Standard
>>> update(file, dat, hdr,'sci') # update the 'sci' extension 
\end_layout

\begin_layout Standard
>>> update(file, dat, 3) # update the 3rd extension 
\end_layout

\begin_layout Standard
>>> update(file, dat, hdr, 3) # update the 3rd extension 
\end_layout

\begin_layout Standard
>>> update(file, dat, 'sci' , 2) # update the 2nd SCI extension 
\end_layout

\begin_layout Standard
>>> update(file, dat, 3, header=hdr) # update the 3rd extension 
\end_layout

\begin_layout Standard
>>> update(file, dat, header=hdr, ext=5) # update the 5th extension
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The update() function will update the specified extension with the input
 data/header.
 The 3rd argument can be the header associated with the data.
 If the 3rd argument is not a header, it (and other positional arguments)
 are assumed to be the extension specification(s).
 Header and extension specs can also be keyword arguments.
 
\end_layout

\begin_layout Standard
Finally, the 
\emph on
info()
\emph default
 function will print out information of the specified FITS file:
\end_layout

\begin_layout Standard
\begin_inset Box Shadowbox
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Standard
>>> pyfits.info('test0.fits') 
\end_layout

\begin_layout Standard
Filename: test0.fits 
\end_layout

\begin_layout Standard
No.
 Name Type Cards Dimensions Format 
\end_layout

\begin_layout Standard
0 PRIMARY PrimaryHDU 138 () Int16 
\end_layout

\begin_layout Standard
1 SCI ImageHDU 61 (400, 400) Int16 
\end_layout

\begin_layout Standard
2 SCI ImageHDU 61 (400, 400) Int16 
\end_layout

\begin_layout Standard
3 SCI ImageHDU 61 (400, 400) Int16 
\end_layout

\begin_layout Standard
4 SCI ImageHDU 61 (400, 400) Int16
\end_layout

\end_inset


\end_layout

\begin_layout Section
FITS Headers
\end_layout

\begin_layout Standard
In the next threee chapters, more detailed information as well as examples
 will be explained for manipulating the header, the image data, and the
 table data respectively.
\end_layout

\begin_layout Subsection
Header of an HDU
\end_layout

\begin_layout Standard
Every HDU normally has two components: header and data.
 In PyFITS these two components are accessed through the two attributes
 of the HDU, 
\emph on
.header
\emph default
 and 
\emph on
.data
\emph default
.
 
\end_layout

\begin_layout Standard
While an HDU may have empty data, i.e.
 the 
\emph on
.data
\emph default
 attribute is None, any HDU will always have a header.
 When an HDU is created with a constructor, e.g.
 
\emph on
hdu=PrimaryHDU(data, header)
\emph default
, the user may supply the 
\emph on
header
\emph default
 value from an existing HDU's header and the data value from a numarray.
 If the defaults (None) are used, the new HDU will have the minimal require
 keyword:
\end_layout

\begin_layout Standard
\begin_inset Box Shadowbox
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Standard
>>> hdu = pyfits.PrimaryHDU() 
\end_layout

\begin_layout Standard
>>> print hdu.header.ascardlist() # show the keywords 
\end_layout

\begin_layout Standard
SIMPLE = T / conforms to FITS standard 
\end_layout

\begin_layout Standard
BITPIX = 8 / array data type 
\end_layout

\begin_layout Standard
NAXIS = 0 / number of array dimensions 
\end_layout

\begin_layout Standard
EXTEND = T
\end_layout

\end_inset


\end_layout

\begin_layout Standard
A user can use any header and any data to construct a new HDU.
 PyFITS will strip the required keywords from the input header first and
 then add back the required keywords compatible to the new HDU.
 So, a user can use a table HDU's header to construct an image HDU and vice
 versa.
 The constructor will also ensure the data type and dimension information
 in the header agree with the data.
\end_layout

\begin_layout Subsection
The Header Attribute
\end_layout

\begin_layout Subsubsection
Value Access and Update
\end_layout

\begin_layout Standard
As shown in the Quick Tutorial, keyword values can be accessed via keyword
 name or index of an HDU's header attribute.
 Here is a quick summary:
\end_layout

\begin_layout Standard
\begin_inset Box Shadowbox
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Standard
>>> hdulist = pyfits.open('input.fits') # open a FITS file 
\end_layout

\begin_layout Standard
>>> prihdr = hdulist[0].header # the primary HDU header 
\end_layout

\begin_layout Standard
>>> print prihdr[3] # get the 4th keyword's value 
\end_layout

\begin_layout Standard
10 
\end_layout

\begin_layout Standard
>>> prihdr[3] = 20 # change it's value 
\end_layout

\begin_layout Standard
>>> print prihdr['darkcorr'] # get the value of the keyword 'darkcorr'
\newline
 'OMIT'
 
\end_layout

\begin_layout Standard
>>> prihdr['darkcorr']= 'PERFORM' # change darkcorr s value
\end_layout

\end_inset


\end_layout

\begin_layout Standard
When reference by the keyword name, it is case insensitive.
 Thus, 
\emph on
prihdr['abc'], prihdr['ABC'], 
\emph default
or
\emph on
 prihdr['aBc']
\emph default
 are all equivalent.
 
\end_layout

\begin_layout Standard
A keyword (and its corresponding Card) can be deleted using the same index/name
 syntax:
\end_layout

\begin_layout Standard
\begin_inset Box Shadowbox
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Standard
>>> del prihdr[3] # delete the 2nd keyword 
\end_layout

\begin_layout Standard
>>> del prihdr['abc'] # get the value of the keyword 'abc' 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Note that, like a regular Python list, the indexing updates after each delete,
 so if 
\emph on
del prihdr[3]
\emph default
 is done two times in a row, the 2nd and 3rd keywords are removed from the
 original header.
 
\end_layout

\begin_layout Standard
Slices are not accepted by the header attribute, so it is not possible to
 do 
\emph on
del prihdr[3:5]
\emph default
, for example.
 
\end_layout

\begin_layout Standard
The method 
\emph on
update(key, value, comment)
\emph default
 is a more versatile way to update keywords.
 It has the flexibility to update an existing keyword and in case the keyword
 does not exist, add it to the header.
 It also allows the use to update both the value and its comment.
 If it is a new keyword, the user can also specify where to put it, using
 the before or after optional argument.
 The default is to append at the end of the header.
\end_layout

\begin_layout Standard
\begin_inset Box Shadowbox
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Standard
>>> prihdr.update('target', 'NGC1234', 'target name') 
\end_layout

\begin_layout Standard
>>> # place the next new keyword before the 'target' keyword 
\end_layout

\begin_layout Standard
>>> prihdr.update('newkey' , 666, before='target') # comment is optional
\end_layout

\begin_layout Standard
>>> # place the next new keyword after the 21st keyword 
\end_layout

\begin_layout Standard
>>> prihdr.update('newkey2', 42.0, 'another new key' , after=20)
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
COMMENT, HISTORY, and Blank Keywords
\end_layout

\begin_layout Standard

\end_layout

\end_body
\end_document
